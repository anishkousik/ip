# AI Usage Tracking

| Tag | AI Agent | Description of Usage | Prompt | Reflection |
|---|:---:|:---|:---|:---|
| Level-3 | Github Copilot | Add mark/unmark functionality and refactor to use a Task class | **Part 1: Add mark/unmark commands**<br><br>**Commands:**<br>- `mark i` - Mark task i as done<br>- `unmark i` - Mark task i as not done<br><br>**Requirements:**<br>- Store completion status in a boolean array<br>- Display `[X]` for done, `[ ]` for not done<br><br>**Part 2: Refactor to use Task class**<br><br>```java<br>public class Task {<br>    private String description;<br>    private boolean isDone;<br>    public Task(String description) {<br>        this.description = description;<br>        this.isDone = false;<br>    }<br>    public String getStatus() {<br>        return (isDone ? "X" : " ");<br>    }<br>}<br>```<br><br>Store all tasks as Task objects in a single array, maintaining all existing functionality. | Very easy to communicate requirements once I understood them. Copilot implemented exactly as specified on the first try, saving significant time. The key was clearly defining data structures, command formats, and output. Noticed it hardcodes output messages by splitting into multiple System.out calls rather than one formatted string. |
| Level-4 | Github Copilot | Add support for three task types (Todo, Deadline, Event) using inheritance and polymorphism | **Requirements:**<br><br>Support three task types:<br>- **Todo:** Basic task without date<br>- **Deadline:** Task with deadline date<br>- **Event:** Task with start and end time<br><br>**Commands:**<br>- `todo <description>`<br>- `deadline <description> /by <date>`<br>- `event <description> /from <start> /to <end>`<br><br>**Implementation:**<br>Use inheritance with Task as parent class, and Todo, Deadline, Event as subclasses. Store all tasks in a single Task[] array using polymorphism. | Straightforward to implement once the hierarchy was clear. Using polymorphism with toString() override made the code cleaner and more maintainable. |
| Level-5 | Github Copilot | Implement comprehensive error handling using custom exceptions | **Error Handling:**<br><br>Create TypeCastException class for TypeCast-specific errors.<br><br>Handle errors for:<br>- Empty todo description<br>- Empty deadline description or date<br>- Empty event fields<br>- Missing format parameters (/by, /from, /to)<br>- Invalid commands<br><br>**Example Errors:**<br>```<br>todo<br>→ The description of a todo cannot be empty.<br><br>blah<br>→ Sorry, that is not a valid command!\br><br>event test<br>→ The format of event should be: event <description> /from <start> /to <end>\br>```<br><br>Wrap command processing in try-catch blocks and display errors gracefully. | Very fast implementation thanks to clearly specifying all error cases. Having a comprehensive list of edge cases to handle meant the AI could generate complete error handling code. Tremendous time savings compared to manually coding each case. However the codebase is starting to look very cluttered so optimisation has to either be done by hand or by better prompting.|
| Level-6 | Github Copilot | Delete function and refactor to use ArrayList | **Add Delete Function:**<br><br>**Command:**<br>- `delete i` - Remove task at index i<br><br>**Expected Output:**<br>```<br>delete 3<br>____________________________________________________________<br>Noted. I've removed this task:<br>  [E][ ] project meeting (from: Aug 6th 2pm to: 4pm)<br>Now you have 4 tasks in the list.<br>____________________________________________________________<br>```<br><br>**Extension: A-Collections**<br><br>Refactor from array-based storage to use Java Collections:<br>- Replace `Task[] tasks` with `ArrayList<Task> tasks`<br>- Update all operations to use ArrayList methods (add, get, remove, size)<br>- Maintain all existing functionality<br><br>Benefits of ArrayList:<br>- Dynamic sizing (no fixed array bounds)<br>- Built-in removal with `.remove()`<br>- Cleaner code (no need to track size manually) | Copilot efficiently refactored the entire codebase from array to ArrayList. Impressive was its ability to track context while updating multiple parts simultaneously - it kept updating code chunks while I approved previous ones without any loss of functionality. The time saved by not manually changing every array reference was instrumental. Also, it automatically updated the user testing file, which was surprising since i did not specify it to do that. It was able to know that since I am adding a new feature, the testing file should also show the feature being added which was very impressive, and shows how testing can be implemented and conducted much more efficiently with AI, and not just coding itself. |
